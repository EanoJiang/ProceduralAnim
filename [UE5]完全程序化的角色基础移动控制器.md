# 程序化Locomoition角色控制器

## 第一个程序动画

创建一个control rig

![1771432079406](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003736840-1957939409.png)

control rig蓝图中，获取骨骼的transform，暂时先控制pelvis来验证该功能，选择Space为全局空间，让过渡Translation的Z轴附加一个sin函数，模拟身体上下浮动

![1771432273355](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003737343-1767167385.png)

选择Use Specific Animation

![1771432468447](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003737557-304339491.png)

效果：

![1771432739182](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003908933-1333027228.gif)

## BasicLegIK

> 基础的腿部IK

### 设置好腿部IK链：thigh-calf-foot，Efector设置为ik_foot

![1771696491553](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025711404-969884943.png)

### 这里还需要设置主次朝向，也就是Primary和Secondaru Axis

Primary Axis为Item A(也就是thigh)，Secondaru Axis为Item B(也就是calf)

thigh_l的坐标系如图(红绿蓝分别对应xyz)：

![1771696810920](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025711855-419014939.png)

calf_l的坐标系如图：

![1771696918143](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025712047-1385117244.png)

大腿需要朝向下，膝盖需要朝向正前

因此Primary Axis的x=-1，Secondaru Axis的y=1

![1771697607866](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025712498-973873507.png)

**Pole Vector（极向量）** ：控制 IK 的关节弯曲方向

因此设置朝向正前

![1771697799806](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025712863-667743868.png)

效果：

![1771698439534](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025713196-595031713.gif)

把控制脚部偏移的节点加进来

![1771699821664](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025713546-251428571.png)

### 用循环来为左右脚都设置IK

先建立一个脚部Transform的列表

![1771713374328](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025713812-1092341731.png)

然后给左右脚都设置好ik，因为右脚的骨骼朝向与左脚相反，所以当index!=0时主次轴朝向都需要乘-1

![1771713587578](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025714045-879843016.png)

效果：

![1771715122305](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025714283-401710303.png)

暂时先删去脚部偏移

![1771721536395](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025714480-1606346751.png)

## FootRotation

> 脚的旋转

### RotateAroundPoint

> 脚绕着目标点旋转

![1771920748639](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182232791-88028342.png)

![1772004217010](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184331416-126447513.png)

> 四元数乘的顺序问题：
>
> | A*B | 先乘B后乘A |
> | --- | ---------- |
>
> 也就是Quat_B要乘以Quat_A的量，因此要旋转的Transform放在B

> RotateVector 节点：
>
> Transform：旋转信息变换，也就是旋转量
>
> Vector：要被旋转的方向向量Vector

### SetFootTransforms

> 根据脚的位置计算脚的旋转方式

如果脚在身体前面，脚绕着脚踝旋转

如果脚在身体后面，脚绕着脚尖旋转

#### Foot以及Ball骨骼的引用

![1771923895200](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182234000-1740565635.png)

![1771923812800](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182234431-94168320.png)

#### 脚踩平台追踪

从每个Foot的z轴(-50,50)追踪脚踩平台的接触点

![1771926458334](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182235059-1884292044.png)

![1771926161002](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182237218-244697539.gif)

#### 脚部放置

设置Foot的Transform属性，Translation(位置)取自脚踩平台高度，Rotation和Scale保持Foot本身的不变

![1771927780254](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182238374-40463336.png)

效果：

![1771928419031](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182241835-2012960109.gif)

#### 脚踩平台旋转偏移

最终脚部的Rotation  = 脚踩平台的Rotation * 脚部的Rotation

![1772006712916](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184332316-1627290789.png)

> 再次强调四元数乘的顺序问题：
>
> | A * B | 先 B，后 A | 子对象（A）在父对象（B）的空间内变换 |
> | ----- | ---------- | ------------------------------------ |
> | B * A | 先 A，后 B | 父对象（B）在子对象（A）的空间内变换 |
>
> A是子对象，B是父对象
>
> 我们需要的是先让脚部按照自身的 `Foot.Rotation` 旋转，然后再将整个脚部（包括它自己的旋转）作为一个整体，跟随平台的 `TargetFootPlatform.Rotation` 进行旋转
>
> 也就是平台先转，脚再跟着平台转，因此是脚踩平台的 `TargetFootPlatform.Rotation`* `Foot.Rotation`，而不是反过来乘

先绕Z轴旋转45度看下效果：

![1772003050920](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184333631-1630878904.png)

![1772006792679](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184334982-1298560636.png)

#### 计算脚踩平台的前后偏移量

向前方向是y = 1

![1772013041788](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184335394-750579281.png)

如果脚在后面，那么点积结果<0，因此就可以根据这两个向量的点积结果来判断脚的位置(相对于脚踩处的位置)

![1772014163983](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184335950-1274931643.png)

因此，(Vector_脚踩平台位置 - Vector_大腿位置) ·(0,1,0)得到的值即为脚部向前偏移量FootForwardOffset

![1772013837859](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184336538-638331927.png)

#### 绕着脚踩平台旋转脚部

删去之前写的Rotation逻辑，直接取用FootRig.Rotation即可

然后再单独处理脚部旋转逻辑：调用之前写的RotateAroundPoint函数，待旋转的是脚部，旋转点和旋转量是脚踩处

![1772015965153](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184337511-775819291.png)

#### 计算脚尖ball的旋转偏移量
