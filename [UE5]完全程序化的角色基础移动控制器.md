# 程序化Locomoition角色控制器

## 第一个程序动画

创建一个control rig

![1771432079406](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003736840-1957939409.png)

control rig蓝图中，获取骨骼的transform，暂时先控制pelvis来验证该功能，选择Space为全局空间，让过渡Translation的Z轴附加一个sin函数，模拟身体上下浮动

![1771432273355](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003737343-1767167385.png)

选择Use Specific Animation

![1771432468447](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003737557-304339491.png)

效果：

![1771432739182](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260219003908933-1333027228.gif)

## BasicLegIK

> 基础的腿部IK

### 设置好腿部IK链：thigh-calf-foot，Efector设置为ik_foot

![1771696491553](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025711404-969884943.png)

### 这里还需要设置主次朝向，也就是Primary和Secondaru Axis

Primary Axis为Item A(也就是thigh)，Secondaru Axis为Item B(也就是calf)

thigh_l的坐标系如图(红绿蓝分别对应xyz)：

![1771696810920](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025711855-419014939.png)

calf_l的坐标系如图：

![1771696918143](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025712047-1385117244.png)

大腿需要朝向下，膝盖需要朝向正前

因此Primary Axis的x=-1，Secondaru Axis的y=1

![1771697607866](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025712498-973873507.png)

**Pole Vector（极向量）** ：控制 IK 的关节弯曲方向

因此设置朝向正前

![1771697799806](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025712863-667743868.png)

效果：

![1771698439534](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025713196-595031713.gif)

把控制脚部偏移的节点加进来

![1771699821664](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025713546-251428571.png)

### 用循环来为左右脚都设置IK

先建立一个脚部Transform的列表

![1771713374328](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025713812-1092341731.png)

然后给左右脚都设置好ik，因为右脚的骨骼朝向与左脚相反，所以当index!=0时主次轴朝向都需要乘-1

![1771713587578](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025714045-879843016.png)

效果：

![1771715122305](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025714283-401710303.png)

暂时先删去脚部偏移

![1771721536395](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224025714480-1606346751.png)

## FootRotation

> 脚的旋转

### RotateAroundPoint

> 脚绕着目标点旋转

也就是“要旋转的物体” 相对于 “旋转中心点” 的旋转偏移，如图所示也就是向量A-B

![1772088881553](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170220091-1554002163.png)

![1772004217010](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184331416-126447513.png)

> 四元数乘的顺序问题：
>
> | A*B | 先乘B后乘A |
> | --- | ---------- |
>
> 也就是Quat_B要乘以Quat_A的量，因此要旋转的Transform放在B

> RotateVector 节点：
>
> Transform：旋转信息变换，也就是旋转量
>
> Vector：要被旋转的方向向量Vector

### SetFootTransforms

> 根据脚的位置计算脚的旋转方式

如果脚在身体前面，脚绕着脚踝旋转

如果脚在身体后面，脚绕着脚前掌旋转

#### Foot以及Ball骨骼的引用

![1771923895200](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182234000-1740565635.png)

![1771923812800](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182234431-94168320.png)

#### 脚踩平台追踪

从每个Foot的z轴(-50,50)追踪脚踩平台的接触点

![1771926458334](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182235059-1884292044.png)

![1771926161002](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182237218-244697539.gif)

#### 脚部放置

设置Foot的Transform属性，Translation(位置)取自脚踩平台高度，Rotation和Scale保持Foot本身的不变

![1771927780254](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182238374-40463336.png)

效果：

![1771928419031](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260224182241835-2012960109.gif)

#### 脚踩平台旋转偏移

最终脚部的Rotation  = 脚踩平台的Rotation * 脚部的Rotation

![1772006712916](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184332316-1627290789.png)

> 再次强调四元数乘的顺序问题：
>
> | A * B | 先 B，后 A | 子对象（A）在父对象（B）的空间内变换 |
> | ----- | ---------- | ------------------------------------ |
> | B * A | 先 A，后 B | 父对象（B）在子对象（A）的空间内变换 |
>
> A是子对象，B是父对象
>
> 我们需要的是先让脚部按照自身的 `Foot.Rotation` 旋转，然后再将整个脚部（包括它自己的旋转）作为一个整体，跟随平台的 `TargetFootPlatform.Rotation` 进行旋转
>
> 也就是平台先转，脚再跟着平台转，因此是脚踩平台的 `TargetFootPlatform.Rotation`* `Foot.Rotation`，而不是反过来乘

先绕Z轴旋转45度看下效果：

![1772003050920](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184333631-1630878904.png)

![1772006792679](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184334982-1298560636.png)

#### 计算脚踩平台的前后偏移量

向前方向是y = 1

![1772013041788](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184335394-750579281.png)

如果脚在后面，那么点积结果<0，因此就可以根据这两个向量的点积结果来判断脚的位置(相对于脚踩处的位置)

![1772014163983](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184335950-1274931643.png)

因此，(Vector_脚踩平台位置 - Vector_大腿位置) ·(0,1,0)得到的值即为脚部向前偏移量FootForwardOffset

![1772013837859](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184336538-638331927.png)

#### 绕着脚踩平台旋转脚部

删去之前写的Rotation逻辑，直接取用FootRig.Rotation即可

然后再单独处理脚部旋转逻辑：调用之前写的RotateAroundPoint函数，待旋转的是脚部，旋转点和旋转量是脚踩处

![1772015965153](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260225184337511-775819291.png)

#### 计算脚前掌ball的旋转偏移点

> **Make Relative** ：将一个变换从全局空间转换为相对于另一个变换的局部空间

全局坐标中，脚前掌旋转点的水平方向XY取自脚前掌，高度Z取自脚踩处

需要变换到脚部Foot的局部坐标

![1772090580544](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170220848-1208799406.png)

在脚部旋转的逻辑处理之后，可视化脚前掌旋转点

> Transform相乘：坐标系转换，通常是子Transform乘以父Transform转换为世界坐标

![1772090515152](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170221415-1268909137.png)

如图中绿色框

![1772075837766](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170221813-786024168.png)

如果脚部的z轴旋转量增大，会发现脚前掌旋转点位置不精确，这是因为最终的LegIK会限制脚部的旋转

#### 计算脚尖tip的旋转偏移点

> ball沿着脚底向前移动一段距离即为tip

脚底向前方向向量 = Vector_脚前掌(ball)- Vector_脚踝(foot)

![1772089335200](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170222220-31913696.png)

脚底向前方向向量 + 脚前掌Ball的世界坐标 = 脚尖旋转偏移点的世界坐标，然后相关于脚前掌的局部坐标

![1772090864997](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170222951-48573394.png)

绘制脚尖旋转偏移点(需要转换为世界坐标)

![1772177837011](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170223535-1116824328.png)

最终得到

![1772089382802](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170223890-1454147542.png)

#### 计算脚后跟heel的旋转偏移点

脚踩点位置 + 脚底向前方向向量*(-0.8) = 脚后跟旋转偏移点的世界坐标，然后相关于脚部的局部坐标

![1772092948348](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170224605-1841208154.png)

绘制脚后跟旋转偏移点

![1772177870868](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170225244-1988844386.png)

最终得到

![1772093237126](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170225616-409653651.png)

#### 所有点位

![1772093487161](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170225971-1752755266.png)

#### 封装绘制这些点位的函数

![1772178342219](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170226605-210759112.png)

![1772178441775](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170227220-287116351.png)

#### 旋转脚部

##### 腿在后面：先绕着脚前掌Ball旋转脚部Foot，再绕着脚尖Tip旋转脚部Foot

因为旋转量是取自脚部向前偏移量，因此把这个偏移量分为两个阶段：(-10 ~ -40)，(-40 ~ -70)

###### 绕着脚前掌Ball旋转脚部Foot

> 旋转量取自脚部向前偏移量，从(-40,-10)Remap为(-25,0)

![1772182237348](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170228029-406061828.png)

暂时关闭SetFinalLegIK

![1772179113059](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170228534-1859221509.png)

设置脚部前后偏移(沿y轴)

![1772179144232](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170228936-184262135.png)

![1772178852073](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170229469-1505452978.png)

修改一下前面计算点位时的Z轴逻辑

脚前掌

![1772178658418](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170229972-166298626.png)

脚后跟

![1772178769163](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170230534-1336774268.png)

取消旋转脚前掌ball

![1772180893796](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170231216-810783063.png)

###### 绕着脚尖Tip旋转脚部Foot

> 旋转量取自脚部向前偏移量，从(-70,-40)Remap为(-30,0)

![1772180915709](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170231943-1594964675.png)

##### 腿在前面：绕着脚后跟heel旋转脚部Foot

![1772181245196](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170232725-790897987.png)

开启SetFinalLegIK

![1772181797229](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170233212-561434100.png)

设置Z轴偏移，防止脚部浮空

![1772181765909](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170233790-1472486525.png)

最终效果：

![1772182929911](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260227170235932-660111330.gif)

## Velocity cycles and leg movement

### 计算速度

> CalculateVelocity

世界空间速度 = (根骨骼世界坐标 - 上一帧的根骨骼世界坐标) / DeltaTime

![1772250962641](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184950432-61572292.png)

骨骼空间速度 = (世界空间速度 + 骨骼位置).转换到骨骼空间 - 骨骼位置

绘制相对于根骨骼的角色速度 = 从根骨骼位置出发 -> (根骨骼位置+骨骼空间速度)

![1772250990422](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184951496-1249100348.png)

![1772251672715](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184952441-1136601168.png)

### 锁定脚部位置的数组

构造一个LockedFootLocationArray

![1772272837034](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184952980-214666193.png)

![1772263836582](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184953514-253908292.png)

根骨骼前后帧的相对变换：`T_now * T_last⁻¹`：相当于 “先撤销上一帧的所有变换（逆操作），再执行当前帧的变换”，最终得到的就是 “从上一帧到当前帧，物体相对动了多少”

![1772262856028](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184954229-1808055187.png)

### 计算Cycle

![1772264943770](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184954649-784097948.png)

![1772264926816](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184955061-800474028.png)

### 计算脚踩目标平台的位置

> CalculateFootTargetPlatform

![1772272870902](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184955529-610894640.png)

![1772272891048](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184955916-744103439.png)

#### 对脚踩目标平台位置进行Lerp线性插值计算

如果处于UnLocked状态，让局部变量脚踩目标平台位置(TempFootPlatform)从 脚部-Lerp->锁定位置，Lerp的阻尼取自Cycle进度

![1772273005885](https://img2024.cnblogs.com/blog/3614909/202602/3614909-20260228184956495-968709934.png)
